/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
	"bytes"
	"context"
	"os"
	"text/template"

	"github.com/Nerzal/gocloak/v13"
	vclusterv1alpha1 "github.com/loft-sh/cluster-api-provider-vcluster/api/v1alpha1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	clusterapiv1beta1 "sigs.k8s.io/cluster-api/api/v1beta1"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/log"

	cloudv1beta1 "seda.club/cloud/api/v1beta1"
)

// CloudClusterReconciler reconciles a CloudCluster object
type CloudClusterReconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

//+kubebuilder:rbac:groups="",resources=secrets,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups="",resources=services,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups="",resources=services/status,verbs=get

func (r *CloudClusterReconciler) CreateKeycloakAccount(ctx context.Context, cluster *cloudv1beta1.CloudCluster) error {
	log := log.FromContext(ctx)
	realm := os.Getenv(("KEYCLOAK_REALM"))
	client := gocloak.NewClient(os.Getenv("KEYCLOAK_BASE_URL"))

	token, err := client.LoginClient(
		ctx,
		os.Getenv("KEYCLOAK_CLIENTID"),
		os.Getenv("KEYCLOAK_CLIENTSECRET"),
		realm,
	)
	if err != nil {
		log.Error(err, "An error occured while instantiating Keycloak Client")
		return err
	}

	clientID := "vcluster-" + cluster.Spec.ProjectID + "-" + cluster.Name
	name := "Cluster " + cluster.Spec.ProjectID + " " + cluster.Name
	description := "Autogenerated by semicolon cloud controller"
	redirectURIS := []string{
		cluster.Name + "." + cluster.Spec.ProjectID + ".kubernetes.cloud.seda.club",
	}

	clients, err := client.GetClients(ctx, token.AccessToken, realm, gocloak.GetClientsParams{
		ClientID: &clientID,
	})
	if err != nil {
		log.Error(err, "An error occured while fetching existing clients")
		return err
	}
	var keycloakClient gocloak.Client
	if len(clients) != 0 {
		keycloakClient = *clients[0]
	} else {
		keycloakClient := gocloak.Client{
			ClientID:     &clientID,
			Name:         &name,
			Description:  &description,
			RedirectURIs: &redirectURIS,
		}

		id, err := client.CreateClient(ctx, token.AccessToken, realm, keycloakClient)
		if err != nil {
			log.Error(err, "An error occured while creating new Keycloak Client")
			return err
		}
		keycloakClient.ID = &id
	}

	credentialRepresentatoin, err := client.RegenerateClientSecret(ctx, token.AccessToken, realm, *keycloakClient.ID)
	if err != nil {
		log.Error(err, "An error occured while getting new Keycloak Client")
		return err
	}

	clientSecret := credentialRepresentatoin.Value

	var secret corev1.Secret
	if err := r.Get(ctx, types.NamespacedName{Name: "cred-" + clientID, Namespace: cluster.Namespace}, &secret); err != nil {
		if !errors.IsNotFound(err) {
			log.Error(err, "An error occured while attempting to fetch existing secret")
			return err
		}
		secret = corev1.Secret{
			ObjectMeta: v1.ObjectMeta{
				Name:      "cred-" + clientID,
				Namespace: cluster.Namespace,
			},
			StringData: map[string]string{
				"clientID":     clientID,
				"clientSecret": *clientSecret,
			},
		}
		if err := r.Create(ctx, &secret); err != nil {
			log.Error(err, "An error occured while creating new secret")
			return err
		}
	} else {
		secret.StringData = map[string]string{
			"clientID":     clientID,
			"clientSecret": *clientSecret,
		}
		if err := r.Update(ctx, &secret); err != nil {
			log.Error(err, "An error occured while updating secret")
			return err
		}
	}

	cluster.Status.KeycloakCredential = &secret.Name
	cluster.Status.KeycloakClientID = keycloakClient.ID
	return nil
}

//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=vclusters,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=vclusters/status,verbs=get
//+kubebuilder:rbac:groups=cluster.x-k8s.io,resources=clusters,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=cluster.x-k8s.io,resources=clusters/status,verbs=get

func (r *CloudClusterReconciler) ProvisionVCluster(ctx context.Context, cluster *cloudv1beta1.CloudCluster) error {
	log := log.FromContext(ctx)

	var newcluster vclusterv1alpha1.VCluster
	vclusterExist := true
	if err := r.Get(ctx, types.NamespacedName{
		Name:      cluster.Name,
		Namespace: cluster.Namespace,
	}, &newcluster); err != nil {
		if !errors.IsNotFound(err) {
			log.Error(err, "An error occured while fetching vcluster")
			return err
		}
		vclusterExist = false
	}
	var apicluster clusterapiv1beta1.Cluster
	apiClusterExist := true

	if err := r.Get(ctx, types.NamespacedName{
		Name:      cluster.Name,
		Namespace: cluster.Namespace,
	}, &apicluster); err != nil {
		if !errors.IsNotFound(err) {
			log.Error(err, "An error occured while fetching cluster-api cluster")
			return err
		}
		apiClusterExist = false
	}

	if !apiClusterExist {
		apicluster = clusterapiv1beta1.Cluster{
			ObjectMeta: v1.ObjectMeta{
				Name:      cluster.Name,
				Namespace: cluster.Namespace,
			},
			Spec: clusterapiv1beta1.ClusterSpec{
				ControlPlaneRef: &corev1.ObjectReference{
					APIVersion: "infrastructure.cluster.x-k8s.io/v1alpha1",
					Kind:       "VCluster",
					Name:       cluster.Name,
				},
				InfrastructureRef: &corev1.ObjectReference{
					APIVersion: "infrastructure.cluster.x-k8s.io/v1alpha1",
					Kind:       "VCluster",
					Name:       cluster.Name,
				},
			},
		}

		if err := r.Create(ctx, &apicluster); err != nil {
			return err
		}
	}

	var buf bytes.Buffer
	type ExecutionContext struct {
		Cluster         cloudv1beta1.CloudCluster
		ClientID        string
		ClientSecret    string
		KeycloakBaseUrl string
		KeycloakRealm   string
	}
	var secret corev1.Secret

	if cluster.Status.KeycloakCredential == nil {
		log.Error(nil, "An error occured while fetching secret for provisioning")
		return errors.NewGone("gone with the winds")
	}
	if err := r.Get(ctx, types.NamespacedName{Name: *cluster.Status.KeycloakCredential, Namespace: cluster.Namespace}, &secret); err != nil {
		log.Error(err, "An error occured while fetching secret for provisioning")
		return err
	}

	var context = ExecutionContext{
		Cluster:         *cluster,
		ClientID:        string(secret.Data["clientID"]),
		ClientSecret:    string(secret.Data["clientSecret"]),
		KeycloakBaseUrl: os.Getenv(("KEYCLOAK_BASE_URL")),
		KeycloakRealm:   os.Getenv(("KEYCLOAK_REALM")),
	}
	k8sversion := os.Getenv("K8S_VERSION")
	helmversion := os.Getenv("HELM_VERSION")

	helmTemplate.Execute(&buf, context)

	if !vclusterExist {
		newcluster = vclusterv1alpha1.VCluster{
			ObjectMeta: v1.ObjectMeta{
				Name:      cluster.Name,
				Namespace: cluster.Namespace,
			},
			Spec: vclusterv1alpha1.VClusterSpec{
				HelmRelease: &vclusterv1alpha1.VirtualClusterHelmRelease{
					Values: buf.String(),
					Chart: vclusterv1alpha1.VirtualClusterHelmChart{
						Version: helmversion,
					},
				},
				KubernetesVersion: &k8sversion,
			},
		}
		if err := r.Create(ctx, &newcluster); err != nil {
			return err
		}
	} else {
		newcluster.Spec.HelmRelease = &vclusterv1alpha1.VirtualClusterHelmRelease{
			Values: buf.String(),
		}
		newcluster.Spec.HelmRelease.Chart.Version = helmversion
		newcluster.Spec.KubernetesVersion = &k8sversion
		if err := r.Update(ctx, &newcluster); err != nil {
			return err
		}
	}
	cluster.Status.ClusterName = &apicluster.Name
	return nil
}

func (r *CloudClusterReconciler) ProvisionTLSTunnel(ctx context.Context, cluster *cloudv1beta1.CloudCluster) error {
	if cluster.Status.AddressName == nil {
		port := "443"
		addr := cloudv1beta1.NetworkAddress{
			ObjectMeta: v1.ObjectMeta{
				Name:      "clusterplane-" + cluster.Name,
				Namespace: cluster.Namespace,
			},
			Spec: cloudv1beta1.NetworkAddressSpec{
				Type:            "domain",
				Address:         cluster.Name + "." + cluster.Spec.ProjectID + ".kubernetes.cloud.seda.club",
				AllowedTLSPorts: &port,
				ExternalAddress: true,
				AllowGateway:    true,
			},
		}
		cluster.Status.AddressName = &addr.Name
		if err := r.Create(ctx, &addr); err != nil {
			if errors.IsAlreadyExists(err) {
				return nil
			}
			return err
		}
	} else {
		var addr cloudv1beta1.NetworkAddress
		if err := r.Get(ctx, types.NamespacedName{Name: *cluster.Status.AddressName, Namespace: cluster.Namespace}, &addr); err != nil {
			if errors.IsNotFound(err) {
				cluster.Status.AddressName = nil
			}
			return err
		}
	}

	if cluster.Status.BindingName == nil {
		addr := cloudv1beta1.NetworkAddressBinding{
			ObjectMeta: v1.ObjectMeta{
				Name:      "clusterplane-" + cluster.Name,
				Namespace: cluster.Namespace,
			},
			Spec: cloudv1beta1.NetworkAddressBindingSpec{
				NetworkAddressGrant: *cluster.Status.AddressName,
				Address:             cluster.Name + "." + cluster.Spec.ProjectID + ".kubernetes.cloud.seda.club",
				ServiceName:         *cluster.Status.ClusterName,
				ConnectionProvider:  "tls-passthrough",
			},
		}
		cluster.Status.BindingName = &addr.Name
		if err := r.Create(ctx, &addr); err != nil {
			if errors.IsAlreadyExists(err) {
				return nil
			}
			return err
		}
	} else {
		var binding cloudv1beta1.NetworkAddressBinding
		if err := r.Get(ctx, types.NamespacedName{Name: *cluster.Status.BindingName, Namespace: cluster.Namespace}, &binding); err != nil {
			if errors.IsNotFound(err) {
				cluster.Status.BindingName = nil
			}
			return err
		}
	}
	return nil
}

func (r *CloudClusterReconciler) deleteExternalResources(ctx context.Context, cluster *cloudv1beta1.CloudCluster) error {
	log := log.FromContext(ctx)
	if cluster.Status.KeycloakClientID != nil {
		realm := os.Getenv(("KEYCLOAK_REALM"))
		client := gocloak.NewClient(os.Getenv("KEYCLOAK_BASE_URL"))

		token, err := client.LoginClient(
			ctx,
			os.Getenv("KEYCLOAK_CLIENTID"),
			os.Getenv("KEYCLOAK_CLIENTSECRET"),
			realm,
		)
		if err != nil {
			log.Error(err, "An error occured while instantiating Keycloak Client")
			return err
		}

		clients, err := client.GetClients(ctx, token.AccessToken, realm, gocloak.GetClientsParams{
			ClientID: cluster.Status.KeycloakClientID,
		})
		if err != nil {
			log.Error(err, "An error occured while fetching existing clients")
			return err
		}
		if len(clients) > 0 {
			if err := client.DeleteClient(ctx, token.AccessToken, realm, *clients[0].ID); err != nil {
				log.Error(err, "An error occured while deleting client")
				return err
			}
			cluster.Status.KeycloakClientID = nil
		}
	}

	if cluster.Status.KeycloakCredential != nil {
		var secret corev1.Secret
		notExist := false
		if err := r.Get(ctx, types.NamespacedName{Name: *cluster.Status.KeycloakCredential, Namespace: cluster.Namespace}, &secret); err != nil {
			if errors.IsNotFound(err) {
				notExist = true
			} else {
				log.Error(err, "An error occured while getting secret")
				return client.IgnoreNotFound(err)
			}
		}
		if !notExist {
			if err := r.Delete(ctx, &secret); err != nil {
				log.Error(err, "An error occured while deleting secret")
				return err
			}

			cluster.Status.KeycloakCredential = nil
		}
	}

	if cluster.Status.ClusterName != nil {
		var apiCluster clusterapiv1beta1.Cluster
		notExist := false
		if err := r.Get(ctx, types.NamespacedName{Name: *cluster.Status.ClusterName, Namespace: cluster.Namespace}, &apiCluster); err != nil {
			if errors.IsNotFound(err) {
				notExist = true
			} else {
				log.Error(err, "An error occured while getting secret")
				return client.IgnoreNotFound(err)
			}
		}
		if !notExist {
			if err := r.Delete(ctx, &apiCluster); err != nil {
				log.Error(err, "An error occured while deleting secret")
				return err
			}
		}
		var vluster vclusterv1alpha1.VCluster
		notExist = false
		if err := r.Get(ctx, types.NamespacedName{Name: *cluster.Status.ClusterName, Namespace: cluster.Namespace}, &vluster); err != nil {
			if errors.IsNotFound(err) {
				notExist = true
			} else {
				log.Error(err, "An error occured while getting secret")
				return client.IgnoreNotFound(err)
			}
		}
		if !notExist {
			if err := r.Delete(ctx, &vluster); err != nil {
				log.Error(err, "An error occured while deleting secret")
				return err
			}
		}

		cluster.Status.ClusterName = nil
	}

	if cluster.Status.BindingName != nil {
		var binding cloudv1beta1.NetworkAddressBinding
		notExist := false
		if err := r.Get(ctx, types.NamespacedName{Name: *cluster.Status.BindingName, Namespace: cluster.Namespace}, &binding); err != nil {
			if errors.IsNotFound(err) {
				notExist = true
			} else {
				log.Error(err, "An error occured while getting secret")
				return client.IgnoreNotFound(err)
			}
		}
		if !notExist {
			if err := r.Delete(ctx, &binding); err != nil {
				log.Error(err, "An error occured while deleting secret")
				return err
			}

			cluster.Status.BindingName = nil
		}
	}
	if cluster.Status.AddressName != nil {
		var address cloudv1beta1.NetworkAddress
		notExist := false
		if err := r.Get(ctx, types.NamespacedName{Name: *cluster.Status.BindingName, Namespace: cluster.Namespace}, &address); err != nil {
			if errors.IsNotFound(err) {
				notExist = true
			} else {
				log.Error(err, "An error occured while getting secret")
				return client.IgnoreNotFound(err)
			}
		}
		if !notExist {
			if err := r.Delete(ctx, &address); err != nil {
				log.Error(err, "An error occured while deleting secret")
				return err
			}

			cluster.Status.AddressName = nil
		}
	}

	return nil
}

//+kubebuilder:rbac:groups=cloud.seda.club,resources=cloudclusters,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=cloud.seda.club,resources=cloudclusters/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=cloud.seda.club,resources=cloudclusters/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the CloudCluster object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.15.0/pkg/reconcile
func (r *CloudClusterReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	log := log.FromContext(ctx)

	var cluster cloudv1beta1.CloudCluster
	if err := r.Client.Get(ctx, req.NamespacedName, &cluster); err != nil {
		log.Error(err, "An error occured while fetching CloudCluster CR")
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}

	// name of our custom finalizer
	myFinalizerName := "cloudcluster.cloud.seda.club/finalizer"

	// examine DeletionTimestamp to determine if object is under deletion
	if cluster.ObjectMeta.DeletionTimestamp.IsZero() {
		// The object is not being deleted, so if it does not have our finalizer,
		// then lets add the finalizer and update the object. This is equivalent
		// registering our finalizer.
		if !controllerutil.ContainsFinalizer(&cluster, myFinalizerName) {
			controllerutil.AddFinalizer(&cluster, myFinalizerName)
			if err := r.Update(ctx, &cluster); err != nil {
				return ctrl.Result{}, err
			}
		}
	} else {
		// The object is being deleted
		if controllerutil.ContainsFinalizer(&cluster, myFinalizerName) {
			// our finalizer is present, so lets handle any external dependency
			if err := r.deleteExternalResources(ctx, &cluster); err != nil {
				// if fail to delete the external dependency here, return with error
				// so that it can be retried
				return ctrl.Result{}, err
			}
			if err := r.Client.Status().Update(ctx, &cluster); err != nil {
				log.Error(err, "An error occured while saving CloudCluster CR")
				return ctrl.Result{}, client.IgnoreNotFound(err)
			}
			if err := r.Client.Get(ctx, req.NamespacedName, &cluster); err != nil {
				log.Error(err, "An error occured while fetching CloudCluster CR")
				return ctrl.Result{}, client.IgnoreNotFound(err)
			}

			// remove our finalizer from the list and update it.
			controllerutil.RemoveFinalizer(&cluster, myFinalizerName)
			if err := r.Update(ctx, &cluster); err != nil {
				return ctrl.Result{}, err
			}
		}

		// Stop reconciliation as the item is being deleted
		return ctrl.Result{}, nil
	}

	if err := r.Client.Get(ctx, req.NamespacedName, &cluster); err != nil {
		log.Error(err, "An error occured while fetching CloudCluster CR")
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}

	if cluster.Status.KeycloakCredential != nil {
		var secret corev1.Secret
		if err := r.Client.Get(ctx, types.NamespacedName{
			Namespace: req.Namespace,
			Name:      *cluster.Status.KeycloakCredential,
		}, &secret); err != nil {
			if errors.IsNotFound(err) {
				cluster.Status.KeycloakCredential = nil
			} else {
				return ctrl.Result{}, err
			}
		}

		if err := r.Client.Status().Update(ctx, &cluster); err != nil {
			log.Error(err, "An error occured while saving CloudCluster CR")
			return ctrl.Result{}, client.IgnoreNotFound(err)
		}
		if err := r.Client.Get(ctx, req.NamespacedName, &cluster); err != nil {
			log.Error(err, "An error occured while fetching CloudCluster CR")
			return ctrl.Result{}, client.IgnoreNotFound(err)
		}

	}

	if cluster.Status.KeycloakCredential == nil || cluster.Status.KeycloakClientID == nil {
		// provision keycloak
		if err := r.CreateKeycloakAccount(ctx, &cluster); err != nil {
			return ctrl.Result{}, err
		}

		if err := r.Client.Status().Update(ctx, &cluster); err != nil {
			log.Error(err, "An error occured while saving CloudCluster CR")
			return ctrl.Result{}, client.IgnoreNotFound(err)
		}
		if err := r.Client.Get(ctx, req.NamespacedName, &cluster); err != nil {
			log.Error(err, "An error occured while fetching CloudCluster CR")
			return ctrl.Result{}, client.IgnoreNotFound(err)
		}

	}

	if err := r.ProvisionVCluster(ctx, &cluster); err != nil {
		if err := r.Client.Status().Update(ctx, &cluster); err != nil {
			log.Error(err, "An error occured while saving CloudCluster CR")
		}

		return ctrl.Result{}, err
	}

	if err := r.ProvisionTLSTunnel(ctx, &cluster); err != nil {
		if err := r.Client.Status().Update(ctx, &cluster); err != nil {
			log.Error(err, "An error occured while saving CloudCluster CR")
		}

		return ctrl.Result{}, err
	}

	if err := r.Client.Status().Update(ctx, &cluster); err != nil {
		log.Error(err, "An error occured while saving CloudCluster CR")
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}

	return ctrl.Result{}, nil
}

var helmTemplate *template.Template

// SetupWithManager sets up the controller with the Manager.
func (r *CloudClusterReconciler) SetupWithManager(mgr ctrl.Manager) error {
	var err error
	helmTemplate, err = template.ParseFiles(os.Getenv("CONFIG_DIR") + "/vcluster.yaml")
	if err != nil {
		return err
	}

	return ctrl.NewControllerManagedBy(mgr).
		For(&cloudv1beta1.CloudCluster{}).
		Complete(r)
}
